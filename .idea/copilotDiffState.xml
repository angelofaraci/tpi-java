<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/src/main/java/com/utn/javaproject/dndsheets/controllers/LevelController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/src/main/java/com/utn/javaproject/dndsheets/controllers/LevelController.java" />
              <option name="originalContent" value="package com.utn.javaproject.dndsheets.controllers;&#10;&#10;import com.utn.javaproject.dndsheets.domain.dto.LevelDto;&#10;import com.utn.javaproject.dndsheets.domain.entities.LevelEntity;&#10;import com.utn.javaproject.dndsheets.domain.entities.LevelKey;&#10;import com.utn.javaproject.dndsheets.mappers.Mapper;&#10;import com.utn.javaproject.dndsheets.services.LevelService;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;public class LevelController {&#10;&#10;    private final Mapper&lt;LevelEntity, LevelDto&gt; levelMapper;&#10;    private final LevelService levelService;&#10;&#10;    public LevelController(Mapper&lt;LevelEntity, LevelDto&gt; levelMapper, LevelService levelService) {&#10;        this.levelMapper = levelMapper;&#10;        this.levelService = levelService;&#10;    }&#10;&#10;    @PutMapping(path = &quot;/levels&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; createLevel(@RequestBody LevelDto levelDto) {&#10;        LevelEntity levelEntity = levelMapper.mapFrom(levelDto);&#10;        LevelEntity savedLevelEntity = levelService.save(levelEntity);&#10;        LevelDto savedLevelDto = levelMapper.mapTo(savedLevelEntity);&#10;        return new ResponseEntity&lt;&gt;(savedLevelDto, HttpStatus.CREATED);&#10;    }&#10;&#10;    @GetMapping(path = &quot;/levels&quot;)&#10;    public List&lt;LevelDto&gt; listLevels() {&#10;        List&lt;LevelEntity&gt; levels = levelService.findAll();&#10;        return levels.stream().map(levelMapper::mapTo).toList();&#10;    }&#10;&#10;    @GetMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; getLevel(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        Optional&lt;LevelEntity&gt; foundLevel = levelService.findOne(levelKey);&#10;&#10;        return foundLevel.map(levelEntity -&gt; {&#10;            LevelDto levelDto = levelMapper.mapTo(levelEntity);&#10;            return new ResponseEntity&lt;&gt;(levelDto, HttpStatus.OK);&#10;        }).orElse(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));&#10;    }&#10;&#10;    @PutMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; fullUpdateLevel(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId,&#10;            @RequestBody LevelDto levelDto) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        if (!levelService.isExists(levelKey)) {&#10;            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#10;        }&#10;&#10;        // Crear un nuevo LevelKeyDto con los IDs del path&#10;        LevelKeyDto levelKeyDto = new LevelKeyDto(characterId, classId);&#10;        levelDto.setId(levelKeyDto);&#10;&#10;        LevelEntity levelEntity = levelMapper.mapFrom(levelDto);&#10;        LevelEntity savedEntity = levelService.save(levelEntity);&#10;        return new ResponseEntity&lt;&gt;(levelMapper.mapTo(savedEntity), HttpStatus.OK);&#10;    }&#10;&#10;    @PatchMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; partialUpdate(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId,&#10;            @RequestBody LevelDto levelDto) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        if (!levelService.isExists(levelKey)) {&#10;            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#10;        }&#10;&#10;        LevelEntity levelEntity = levelMapper.mapFrom(levelDto);&#10;        LevelEntity updatedLevel = levelService.partialUpdate(levelKey, levelEntity);&#10;        return new ResponseEntity&lt;&gt;(levelMapper.mapTo(updatedLevel), HttpStatus.OK);&#10;    }&#10;&#10;    @DeleteMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity deleteLevel(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        levelService.delete(levelKey);&#10;        return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.utn.javaproject.dndsheets.controllers;&#10;&#10;import com.utn.javaproject.dndsheets.domain.dto.LevelDto;&#10;import com.utn.javaproject.dndsheets.domain.entities.LevelEntity;&#10;import com.utn.javaproject.dndsheets.domain.entities.LevelKey;&#10;import com.utn.javaproject.dndsheets.mappers.Mapper;&#10;import com.utn.javaproject.dndsheets.services.LevelService;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;@RestController&#10;public class LevelController {&#10;&#10;    private final Mapper&lt;LevelEntity, LevelDto&gt; levelMapper;&#10;    private final LevelService levelService;&#10;&#10;    public LevelController(Mapper&lt;LevelEntity, LevelDto&gt; levelMapper, LevelService levelService) {&#10;        this.levelMapper = levelMapper;&#10;        this.levelService = levelService;&#10;    }&#10;&#10;    @PutMapping(path = &quot;/levels&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; createLevel(@RequestBody LevelDto levelDto) {&#10;        LevelEntity levelEntity = levelMapper.mapFrom(levelDto);&#10;        LevelEntity savedLevelEntity = levelService.save(levelEntity);&#10;        LevelDto savedLevelDto = levelMapper.mapTo(savedLevelEntity);&#10;        return new ResponseEntity&lt;&gt;(savedLevelDto, HttpStatus.CREATED);&#10;    }&#10;&#10;    @GetMapping(path = &quot;/levels&quot;)&#10;    public List&lt;LevelDto&gt; listLevels() {&#10;        List&lt;LevelEntity&gt; levels = levelService.findAll();&#10;        return levels.stream().map(levelMapper::mapTo).toList();&#10;    }&#10;&#10;    @GetMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; getLevel(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        Optional&lt;LevelEntity&gt; foundLevel = levelService.findOne(levelKey);&#10;&#10;        return foundLevel.map(levelEntity -&gt; {&#10;            LevelDto levelDto = levelMapper.mapTo(levelEntity);&#10;            return new ResponseEntity&lt;&gt;(levelDto, HttpStatus.OK);&#10;        }).orElse(new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND));&#10;    }&#10;&#10;    @PutMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; fullUpdateLevel(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId,&#10;            @RequestBody LevelDto levelDto) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        if (!levelService.isExists(levelKey)) {&#10;            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#10;        }&#10;&#10;        // Crear un nuevo LevelKeyDto con los IDs del path&#10;        LevelKeyDto levelKeyDto = new LevelKeyDto(characterId, classId);&#10;        levelDto.setId(levelKeyDto);&#10;&#10;        LevelEntity levelEntity = levelMapper.mapFrom(levelDto);&#10;        LevelEntity savedEntity = levelService.save(levelEntity);&#10;        return new ResponseEntity&lt;&gt;(levelMapper.mapTo(savedEntity), HttpStatus.OK);&#10;    }&#10;&#10;    @PatchMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity&lt;LevelDto&gt; partialUpdate(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId,&#10;            @RequestBody LevelDto levelDto) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        if (!levelService.isExists(levelKey)) {&#10;            return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND);&#10;        }&#10;&#10;        LevelEntity levelEntity = levelMapper.mapFrom(levelDto);&#10;        LevelEntity updatedLevel = levelService.partialUpdate(levelKey, levelEntity);&#10;        return new ResponseEntity&lt;&gt;(levelMapper.mapTo(updatedLevel), HttpStatus.OK);&#10;    }&#10;&#10;    @DeleteMapping(path = &quot;/level/{characterId}/{classId}&quot;)&#10;    public ResponseEntity deleteLevel(&#10;            @PathVariable(&quot;characterId&quot;) Long characterId,&#10;            @PathVariable(&quot;classId&quot;) Long classId) {&#10;&#10;        LevelKey levelKey = new LevelKey(characterId, classId);&#10;        levelService.delete(levelKey);&#10;        return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>